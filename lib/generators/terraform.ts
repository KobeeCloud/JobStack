import { Node, Edge } from '@xyflow/react'
import { getComponentById } from '@/lib/catalog'

export interface TerraformOutput {
  code: string
  filename: string
  provider: string
}

interface NodeData {
  label?: string
  componentId: string
  config?: Record<string, any>
  [key: string]: unknown
}

export function generateTerraform(nodes: Node<NodeData>[], edges: Edge[]): TerraformOutput[] {
  const outputs: TerraformOutput[] = []
  const providers = new Set<string>()
  const resources: string[] = []

  // Group nodes by provider
  const nodesByProvider: Record<string, Node<NodeData>[]> = {}

  nodes.forEach(node => {
    const component = getComponentById(node.data.componentId)
    if (!component || !component.terraform) return

    const provider = component.terraform.provider
    providers.add(provider)

    if (!nodesByProvider[provider]) {
      nodesByProvider[provider] = []
    }
    nodesByProvider[provider].push(node)
  })

  // Generate main.tf with provider configurations
  let mainTf = '# Generated by JobStack - Infrastructure Planning Tool\n\n'

  // Add Terraform required providers
  if (providers.size > 0) {
    mainTf += 'terraform {\n'
    mainTf += '  required_providers {\n'

    if (providers.has('aws')) {
      mainTf += '    aws = {\n'
      mainTf += '      source  = "hashicorp/aws"\n'
      mainTf += '      version = "~> 5.0"\n'
      mainTf += '    }\n'
    }
    if (providers.has('gcp')) {
      mainTf += '    google = {\n'
      mainTf += '      source  = "hashicorp/google"\n'
      mainTf += '      version = "~> 5.0"\n'
      mainTf += '    }\n'
    }
    if (providers.has('azure')) {
      mainTf += '    azurerm = {\n'
      mainTf += '      source  = "hashicorp/azurerm"\n'
      mainTf += '      version = "~> 3.0"\n'
      mainTf += '    }\n'
    }
    if (providers.has('vercel')) {
      mainTf += '    vercel = {\n'
      mainTf += '      source  = "vercel/vercel"\n'
      mainTf += '      version = "~> 1.0"\n'
      mainTf += '    }\n'
    }
    if (providers.has('cloudflare')) {
      mainTf += '    cloudflare = {\n'
      mainTf += '      source  = "cloudflare/cloudflare"\n'
      mainTf += '      version = "~> 4.0"\n'
      mainTf += '    }\n'
    }

    mainTf += '  }\n'
    mainTf += '}\n\n'
  }

  // Add provider configurations
  if (providers.has('aws')) {
    mainTf += 'provider "aws" {\n'
    mainTf += '  region = var.aws_region\n'
    mainTf += '}\n\n'
  }
  if (providers.has('gcp')) {
    mainTf += 'provider "google" {\n'
    mainTf += '  project = var.gcp_project\n'
    mainTf += '  region  = var.gcp_region\n'
    mainTf += '}\n\n'
  }
  if (providers.has('azure')) {
    mainTf += 'provider "azurerm" {\n'
    mainTf += '  features {}\n'
    mainTf += '}\n\n'
  }
  if (providers.has('vercel')) {
    mainTf += 'provider "vercel" {\n'
    mainTf += '  api_token = var.vercel_api_token\n'
    mainTf += '}\n\n'
  }

  outputs.push({
    code: mainTf,
    filename: 'main.tf',
    provider: 'terraform'
  })

  // Generate variables.tf
  let variablesTf = '# Variables\n\n'

  if (providers.has('aws')) {
    variablesTf += 'variable "aws_region" {\n'
    variablesTf += '  description = "AWS region"\n'
    variablesTf += '  type        = string\n'
    variablesTf += '  default     = "us-east-1"\n'
    variablesTf += '}\n\n'
  }
  if (providers.has('gcp')) {
    variablesTf += 'variable "gcp_project" {\n'
    variablesTf += '  description = "GCP project ID"\n'
    variablesTf += '  type        = string\n'
    variablesTf += '}\n\n'
    variablesTf += 'variable "gcp_region" {\n'
    variablesTf += '  description = "GCP region"\n'
    variablesTf += '  type        = string\n'
    variablesTf += '  default     = "us-central1"\n'
    variablesTf += '}\n\n'
  }
  if (providers.has('azure')) {
    variablesTf += 'variable "azure_location" {\n'
    variablesTf += '  description = "Azure region/location"\n'
    variablesTf += '  type        = string\n'
    variablesTf += '  default     = "westeurope"\n'
    variablesTf += '}\n\n'
    variablesTf += 'variable "azure_resource_group" {\n'
    variablesTf += '  description = "Azure Resource Group name"\n'
    variablesTf += '  type        = string\n'
    variablesTf += '  default     = "rg-jobstack"\n'
    variablesTf += '}\n\n'
  }
  if (providers.has('vercel')) {
    variablesTf += 'variable "vercel_api_token" {\n'
    variablesTf += '  description = "Vercel API token"\n'
    variablesTf += '  type        = string\n'
    variablesTf += '  sensitive   = true\n'
    variablesTf += '}\n\n'
  }

  // Always add environment variable
  variablesTf += 'variable "environment" {\n'
  variablesTf += '  description = "Environment name (e.g., dev, staging, prod)"\n'
  variablesTf += '  type        = string\n'
  variablesTf += '  default     = "dev"\n'
  variablesTf += '}\n\n'

  variablesTf += 'variable "project_name" {\n'
  variablesTf += '  description = "Project name for resource naming"\n'
  variablesTf += '  type        = string\n'
  variablesTf += '  default     = "jobstack"\n'
  variablesTf += '}\n\n'

  outputs.push({
    code: variablesTf,
    filename: 'variables.tf',
    provider: 'terraform'
  })

  // Generate resources for each node
  let resourcesTf = '# Resources\n\n'

  // Resources that support tags
  const resourcesWithTags = [
    'aws_', 'azurerm_', 'google_'
  ]

  // Resources that don't support tags block
  const noTagsResources = [
    'azurerm_subnet', 'azurerm_network_interface', 'aws_subnet',
    'aws_security_group_rule', 'aws_route', 'google_compute_subnetwork',
    'google_compute_firewall', 'vercel_', 'cloudflare_'
  ]

  nodes.forEach(node => {
    const component = getComponentById(node.data.componentId)
    if (!component || !component.terraform) return

    const resourceName = (node.data.label || component.name).toLowerCase().replace(/[^a-z0-9]/g, '_')
    const resourceType = component.terraform.resource
    const config = { ...component.terraform.defaultConfig, ...node.data.config }

    resourcesTf += `resource "${resourceType}" "${resourceName}" {\n`

    // Add name/display_name based on provider
    if (resourceType.startsWith('azurerm_')) {
      resourcesTf += `  name                = "\${var.project_name}-${resourceName}"\n`
      resourcesTf += `  location            = var.azure_location\n`
      resourcesTf += `  resource_group_name = var.azure_resource_group\n`
    } else if (resourceType.startsWith('aws_')) {
      // AWS resources typically use name in tags, not as attribute
    } else if (resourceType.startsWith('google_')) {
      resourcesTf += `  name    = "\${var.project_name}-${resourceName}"\n`
      resourcesTf += `  project = var.gcp_project\n`
    }

    // Add configuration properties
    Object.entries(config).forEach(([key, value]) => {
      if (typeof value === 'object' && !Array.isArray(value) && value !== null) {
        resourcesTf += `  ${key} {\n`
        Object.entries(value).forEach(([subKey, subValue]) => {
          resourcesTf += `    ${subKey} = ${JSON.stringify(subValue)}\n`
        })
        resourcesTf += `  }\n`
      } else if (Array.isArray(value)) {
        resourcesTf += `  ${key} = ${JSON.stringify(value)}\n`
      } else if (value !== null && value !== undefined) {
        resourcesTf += `  ${key} = ${JSON.stringify(value)}\n`
      }
    })

    // Add tags only for resources that support them
    const supportsTags = resourcesWithTags.some(prefix => resourceType.startsWith(prefix))
    const excludeTags = noTagsResources.some(prefix => resourceType.startsWith(prefix))

    if (supportsTags && !excludeTags) {
      resourcesTf += '  tags = {\n'
      resourcesTf += `    Name        = "\${var.project_name}-${resourceName}"\n`
      resourcesTf += '    Environment = var.environment\n'
      resourcesTf += '    ManagedBy   = "JobStack"\n'
      resourcesTf += '  }\n'
    }

    resourcesTf += '}\n\n'
  })

  outputs.push({
    code: resourcesTf,
    filename: 'resources.tf',
    provider: 'terraform'
  })

  // Generate outputs.tf
  let outputsTf = '# Outputs\n\n'

  nodes.forEach(node => {
    const component = getComponentById(node.data.componentId)
    if (!component || !component.terraform) return

    const resourceName = (node.data.label || component.name).toLowerCase().replace(/[^a-z0-9]/g, '_')
    const resourceType = component.terraform.resource

    outputsTf += `output "${resourceName}_id" {\n`
    outputsTf += `  description = "ID of ${node.data.label}"\n`
    outputsTf += `  value       = ${resourceType}.${resourceName}.id\n`
    outputsTf += '}\n\n'
  })

  outputs.push({
    code: outputsTf,
    filename: 'outputs.tf',
    provider: 'terraform'
  })

  return outputs
}

export function generateTerraformReadme(nodes: Node<NodeData>[]): string {
  return `# Infrastructure as Code - Generated by JobStack

## Overview

This Terraform configuration was automatically generated from your infrastructure diagram.

**Total Components:** ${nodes.length}

## Prerequisites

- [Terraform](https://www.terraform.io/downloads.html) >= 1.0
- Cloud provider credentials configured

## Quick Start

1. **Initialize Terraform:**
   \`\`\`bash
   terraform init
   \`\`\`

2. **Review the plan:**
   \`\`\`bash
   terraform plan
   \`\`\`

3. **Apply the configuration:**
   \`\`\`bash
   terraform apply
   \`\`\`

4. **Destroy resources (when needed):**
   \`\`\`bash
   terraform destroy
   \`\`\`

## Configuration

Create a \`terraform.tfvars\` file with your values:

\`\`\`hcl
aws_region = "us-east-1"
environment = "production"
\`\`\`

## Components

${nodes.map(node => {
  const component = getComponentById(node.data.componentId)
  return `- **${node.data.label}** (${component?.name || 'Unknown'})`
}).join('\n')}

## Cost Estimate

Estimated monthly cost: $${calculateTotalCost(nodes).min} - $${calculateTotalCost(nodes).max}

*Note: Actual costs may vary based on usage and configuration.*

## Support

Generated by JobStack - Visual Infrastructure Planning Tool
`
}

function calculateTotalCost(nodes: Node<NodeData>[]): { min: number; max: number } {
  let min = 0
  let max = 0

  nodes.forEach(node => {
    const component = getComponentById(node.data.componentId)
    if (component) {
      min += component.estimatedCost.min
      max += component.estimatedCost.max
    }
  })

  return { min, max }
}
