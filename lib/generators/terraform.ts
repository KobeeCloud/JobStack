import { Node, Edge } from '@xyflow/react'
import { getComponentById } from '@/lib/catalog'

export interface TerraformOutput {
  code: string
  filename: string
  provider: string
}

export interface TerraformError {
  nodeId: string
  nodeLabel: string
  error: string
}

export interface TerraformResult {
  success: boolean
  files: TerraformOutput[]
  errors: TerraformError[]
  warnings: string[]
  skippedCount: number
}

interface NodeData {
  label?: string
  componentId?: string
  component?: string
  config?: Record<string, any>
  [key: string]: unknown
}

function getNodeComponentId(node: Node<NodeData>): string | undefined {
  return node.data?.componentId || node.data?.component
}

export function generateTerraformWithValidation(nodes: Node<NodeData>[], _edges: Edge[]): TerraformResult {
  const outputs: TerraformOutput[] = []
  const errors: TerraformError[] = []
  const warnings: string[] = []
  const providers = new Set<string>()
  let skippedCount = 0

  if (!nodes || nodes.length === 0) {
    return {
      success: false,
      files: [],
      errors: [{ nodeId: '', nodeLabel: 'Diagram', error: 'No components found. Add components to generate Terraform.' }],
      warnings: [],
      skippedCount: 0
    }
  }

  const validNodes: Node<NodeData>[] = []
  const nodesByProvider: Record<string, Node<NodeData>[]> = {}

  nodes.forEach(node => {
    const componentId = getNodeComponentId(node)
    
    if (!componentId) {
      errors.push({ nodeId: node.id, nodeLabel: String(node.data?.label || 'Unknown'), error: 'Missing component ID' })
      skippedCount++
      return
    }

    const component = getComponentById(componentId)
    
    if (!component) {
      errors.push({ nodeId: node.id, nodeLabel: String(node.data?.label || componentId), error: `Unknown component: ${componentId}` })
      skippedCount++
      return
    }

    if (!component.terraform) {
      warnings.push(`${node.data?.label || component.name}: No Terraform support (skipped)`)
      skippedCount++
      return
    }

    validNodes.push(node)
    providers.add(component.terraform.provider)
    if (!nodesByProvider[component.terraform.provider]) nodesByProvider[component.terraform.provider] = []
    nodesByProvider[component.terraform.provider].push(node)
  })

  if (validNodes.length === 0) {
    return {
      success: false,
      files: [],
      errors: errors.length > 0 ? errors : [{ nodeId: '', nodeLabel: 'Diagram', error: 'No components with Terraform support. Add AWS/Azure/GCP components.' }],
      warnings,
      skippedCount
    }
  }

  // Generate main.tf
  let mainTf = '# Generated by JobStack\n# Components: ' + validNodes.length + ' | Skipped: ' + skippedCount + '\n\n'
  mainTf += 'terraform {\n  required_version = ">= 1.0"\n  required_providers {\n'
  if (providers.has('aws')) mainTf += '    aws = { source = "hashicorp/aws", version = "~> 5.0" }\n'
  if (providers.has('gcp')) mainTf += '    google = { source = "hashicorp/google", version = "~> 5.0" }\n'
  if (providers.has('azure')) mainTf += '    azurerm = { source = "hashicorp/azurerm", version = "~> 3.0" }\n'
  if (providers.has('vercel')) mainTf += '    vercel = { source = "vercel/vercel", version = "~> 1.0" }\n'
  if (providers.has('cloudflare')) mainTf += '    cloudflare = { source = "cloudflare/cloudflare", version = "~> 4.0" }\n'
  mainTf += '  }\n}\n\n'
  
  if (providers.has('aws')) mainTf += 'provider "aws" { region = var.aws_region }\n\n'
  if (providers.has('gcp')) mainTf += 'provider "google" { project = var.gcp_project\n  region = var.gcp_region }\n\n'
  if (providers.has('azure')) mainTf += 'provider "azurerm" { features {} }\n\n'
  if (providers.has('vercel')) mainTf += 'provider "vercel" { api_token = var.vercel_api_token }\n\n'
  if (providers.has('cloudflare')) mainTf += 'provider "cloudflare" { api_token = var.cloudflare_api_token }\n\n'
  
  outputs.push({ code: mainTf, filename: 'main.tf', provider: 'terraform' })

  // Generate variables.tf
  let variablesTf = '# Variables\n\n'
  if (providers.has('aws')) variablesTf += 'variable "aws_region" {\n  type = string\n  default = "us-east-1"\n}\n\n'
  if (providers.has('gcp')) {
    variablesTf += 'variable "gcp_project" { type = string }\n\n'
    variablesTf += 'variable "gcp_region" { type = string\n  default = "us-central1" }\n\n'
  }
  if (providers.has('azure')) {
    variablesTf += 'variable "azure_location" { type = string\n  default = "westeurope" }\n\n'
    variablesTf += 'variable "azure_resource_group" { type = string\n  default = "rg-jobstack" }\n\n'
  }
  if (providers.has('vercel')) variablesTf += 'variable "vercel_api_token" { type = string\n  sensitive = true }\n\n'
  if (providers.has('cloudflare')) variablesTf += 'variable "cloudflare_api_token" { type = string\n  sensitive = true }\n\n'
  variablesTf += 'variable "environment" { type = string\n  default = "dev" }\n\n'
  variablesTf += 'variable "project_name" { type = string\n  default = "jobstack" }\n\n'
  outputs.push({ code: variablesTf, filename: 'variables.tf', provider: 'terraform' })

  // Generate resources.tf
  let resourcesTf = '# Resources\n\n'
  const noTagsResources = ['azurerm_subnet', 'azurerm_network_interface', 'aws_subnet', 'aws_security_group_rule', 'aws_route', 'google_compute_subnetwork', 'google_compute_firewall', 'vercel_', 'cloudflare_']

  validNodes.forEach(node => {
    const componentId = getNodeComponentId(node)!
    const component = getComponentById(componentId)!
    const resourceName = (node.data.label || component.name).toLowerCase().replace(/[^a-z0-9]/g, '_')
    const resourceType = component.terraform!.resource
    const config = { ...component.terraform!.defaultConfig, ...node.data.config }

    resourcesTf += 'resource "' + resourceType + '" "' + resourceName + '" {\n'
    if (resourceType.startsWith('azurerm_')) {
      resourcesTf += '  name = "${var.project_name}-' + resourceName + '"\n'
      resourcesTf += '  location = var.azure_location\n'
      resourcesTf += '  resource_group_name = var.azure_resource_group\n'
    } else if (resourceType.startsWith('google_')) {
      resourcesTf += '  name = "${var.project_name}-' + resourceName + '"\n'
      resourcesTf += '  project = var.gcp_project\n'
    }

    Object.entries(config).forEach(([key, value]) => {
      if (typeof value === 'object' && !Array.isArray(value) && value !== null) {
        resourcesTf += '  ' + key + ' {\n'
        Object.entries(value as Record<string, unknown>).forEach(([subKey, subValue]) => {
          resourcesTf += '    ' + subKey + ' = ' + JSON.stringify(subValue) + '\n'
        })
        resourcesTf += '  }\n'
      } else if (value !== null && value !== undefined) {
        resourcesTf += '  ' + key + ' = ' + JSON.stringify(value) + '\n'
      }
    })

    const supportsTags = resourceType.startsWith('aws_') || resourceType.startsWith('azurerm_') || resourceType.startsWith('google_')
    const excludeTags = noTagsResources.some(prefix => resourceType.startsWith(prefix))
    if (supportsTags && !excludeTags) {
      resourcesTf += '  tags = {\n    Name = "${var.project_name}-' + resourceName + '"\n    Environment = var.environment\n    ManagedBy = "JobStack"\n  }\n'
    }
    resourcesTf += '}\n\n'
  })
  outputs.push({ code: resourcesTf, filename: 'resources.tf', provider: 'terraform' })

  // Generate outputs.tf
  let outputsTf = '# Outputs\n\n'
  validNodes.forEach(node => {
    const componentId = getNodeComponentId(node)!
    const component = getComponentById(componentId)!
    const resourceName = (node.data.label || component.name).toLowerCase().replace(/[^a-z0-9]/g, '_')
    const resourceType = component.terraform!.resource
    outputsTf += 'output "' + resourceName + '_id" {\n  value = ' + resourceType + '.' + resourceName + '.id\n}\n\n'
  })
  outputs.push({ code: outputsTf, filename: 'outputs.tf', provider: 'terraform' })

  return { success: errors.length === 0, files: outputs, errors, warnings, skippedCount }
}

export function generateTerraform(nodes: Node<NodeData>[], edges: Edge[]): TerraformOutput[] {
  const result = generateTerraformWithValidation(nodes, edges)
  if (!result.success && result.files.length === 0) {
    throw new Error(result.errors.map(e => e.error).join('; ') || 'Cannot generate Terraform')
  }
  return result.files
}

export function generateTerraformReadme(nodes: Node<NodeData>[]): string {
  const validNodes = nodes.filter(n => {
    const id = getNodeComponentId(n)
    return id && getComponentById(id)?.terraform
  })
  const cost = calculateTotalCost(nodes)
  return '# Infrastructure as Code - JobStack\n\n## Overview\nComponents: ' + validNodes.length + '\nEstimated Cost: $' + cost.min + ' - $' + cost.max + '/month\n\n## Quick Start\n```bash\nterraform init\nterraform plan\nterraform apply\n```\n'
}

function calculateTotalCost(nodes: Node<NodeData>[]): { min: number; max: number } {
  let min = 0, max = 0
  nodes.forEach(node => {
    const id = getNodeComponentId(node)
    if (id) {
      const c = getComponentById(id)
      if (c) { min += c.estimatedCost.min; max += c.estimatedCost.max }
    }
  })
  return { min, max }
}
