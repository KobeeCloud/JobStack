import { Node, Edge } from '@xyflow/react'

/**
 * AWS CloudFormation Generator
 * Converts diagram to CloudFormation YAML/JSON templates
 */

interface CloudFormationResource {
  Type: string
  Properties: Record<string, unknown>
  DependsOn?: string[]
}

interface CloudFormationTemplate {
  AWSTemplateFormatVersion: string
  Description: string
  Parameters: Record<string, unknown>
  Resources: Record<string, CloudFormationResource>
  Outputs: Record<string, unknown>
}

// Map our component types to CloudFormation resource types
const CFN_MAPPINGS: Record<string, { type: string; defaultProps: Record<string, unknown> }> = {
  'aws-vpc': { 
    type: 'AWS::EC2::VPC', 
    defaultProps: { CidrBlock: '10.0.0.0/16', EnableDnsSupport: true, EnableDnsHostnames: true } 
  },
  'aws-subnet': { 
    type: 'AWS::EC2::Subnet', 
    defaultProps: { CidrBlock: '10.0.1.0/24' } 
  },
  'aws-security-group': { 
    type: 'AWS::EC2::SecurityGroup', 
    defaultProps: { GroupDescription: 'Security group created by JobStack' } 
  },
  'aws-ec2': { 
    type: 'AWS::EC2::Instance', 
    defaultProps: { InstanceType: 't3.micro', ImageId: '{{resolve:ssm:/aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2}}' } 
  },
  'aws-lambda': { 
    type: 'AWS::Lambda::Function', 
    defaultProps: { Runtime: 'nodejs18.x', Handler: 'index.handler', MemorySize: 128, Timeout: 30 } 
  },
  'aws-s3': { 
    type: 'AWS::S3::Bucket', 
    defaultProps: { PublicAccessBlockConfiguration: { BlockPublicAcls: true, BlockPublicPolicy: true } } 
  },
  'aws-rds': { 
    type: 'AWS::RDS::DBInstance', 
    defaultProps: { DBInstanceClass: 'db.t3.micro', AllocatedStorage: '20', Engine: 'postgres' } 
  },
  'aws-dynamodb': { 
    type: 'AWS::DynamoDB::Table', 
    defaultProps: { BillingMode: 'PAY_PER_REQUEST', AttributeDefinitions: [{ AttributeName: 'id', AttributeType: 'S' }], KeySchema: [{ AttributeName: 'id', KeyType: 'HASH' }] } 
  },
  'aws-alb': { 
    type: 'AWS::ElasticLoadBalancingV2::LoadBalancer', 
    defaultProps: { Type: 'application', Scheme: 'internet-facing' } 
  },
  'aws-eks': { 
    type: 'AWS::EKS::Cluster', 
    defaultProps: { Version: '1.28' } 
  },
  'aws-ecs': { 
    type: 'AWS::ECS::Cluster', 
    defaultProps: { ClusterSettings: [{ Name: 'containerInsights', Value: 'enabled' }] } 
  },
  'aws-api-gateway': { 
    type: 'AWS::ApiGateway::RestApi', 
    defaultProps: { EndpointConfiguration: { Types: ['REGIONAL'] } } 
  },
  'aws-cloudfront': { 
    type: 'AWS::CloudFront::Distribution', 
    defaultProps: {} 
  },
  'aws-sqs': { 
    type: 'AWS::SQS::Queue', 
    defaultProps: { VisibilityTimeout: 30, MessageRetentionPeriod: 345600 } 
  },
  'aws-sns': { 
    type: 'AWS::SNS::Topic', 
    defaultProps: {} 
  },
  'aws-cognito': { 
    type: 'AWS::Cognito::UserPool', 
    defaultProps: { MfaConfiguration: 'OFF', UserPoolName: 'JobStackUserPool' } 
  },
  'aws-elasticache': { 
    type: 'AWS::ElastiCache::CacheCluster', 
    defaultProps: { Engine: 'redis', CacheNodeType: 'cache.t3.micro', NumCacheNodes: 1 } 
  },
}

function sanitizeCfnName(name: string): string {
  return name
    .replace(/[^a-zA-Z0-9]/g, '')
    .replace(/^[0-9]/, 'R$&')
}

export function generateCloudFormation(nodes: Node[], edges: Edge[], format: 'yaml' | 'json' = 'yaml'): string {
  const template: CloudFormationTemplate = {
    AWSTemplateFormatVersion: '2010-09-09',
    Description: 'Infrastructure template generated by JobStack',
    Parameters: {
      Environment: {
        Type: 'String',
        Default: 'development',
        AllowedValues: ['development', 'staging', 'production'],
        Description: 'Deployment environment',
      },
    },
    Resources: {},
    Outputs: {},
  }

  const nodeIdToName = new Map<string, string>()

  // Generate resources
  for (const node of nodes) {
    const type = node.type || ''
    const mapping = CFN_MAPPINGS[type]
    
    if (!mapping) continue

    const resourceName = sanitizeCfnName(String(node.data?.label || node.id))
    nodeIdToName.set(node.id, resourceName)

    const resource: CloudFormationResource = {
      Type: mapping.type,
      Properties: {
        ...mapping.defaultProps,
        Tags: [
          { Key: 'Name', Value: node.data?.label || resourceName },
          { Key: 'Environment', Value: { Ref: 'Environment' } },
          { Key: 'ManagedBy', Value: 'CloudFormation' },
          { Key: 'GeneratedFrom', Value: 'JobStack' },
        ],
      },
    }

    template.Resources[resourceName] = resource

    // Add outputs for key resources
    if (['aws-vpc', 'aws-s3', 'aws-rds', 'aws-alb', 'aws-eks', 'aws-api-gateway'].includes(type)) {
      template.Outputs[`${resourceName}Id`] = {
        Description: `ID of ${resourceName}`,
        Value: { Ref: resourceName },
        Export: { Name: { 'Fn::Sub': `\${AWS::StackName}-${resourceName}Id` } },
      }
    }
  }

  // Add dependencies from edges
  for (const edge of edges) {
    const sourceName = nodeIdToName.get(edge.source)
    const targetName = nodeIdToName.get(edge.target)
    if (sourceName && targetName && template.Resources[targetName]) {
      const resource = template.Resources[targetName]
      if (!resource.DependsOn) {
        resource.DependsOn = []
      }
      if (!resource.DependsOn.includes(sourceName)) {
        resource.DependsOn.push(sourceName)
      }
    }
  }

  if (format === 'json') {
    return JSON.stringify(template, null, 2)
  }

  // Convert to YAML
  return convertToYaml(template)
}

function convertToYaml(obj: unknown, indent = 0): string {
  const spaces = '  '.repeat(indent)
  
  if (obj === null || obj === undefined) {
    return 'null'
  }
  
  if (typeof obj === 'string') {
    if (obj.includes('\n') || obj.includes(':') || obj.includes('#')) {
      return `"${obj.replace(/"/g, '\\"')}"`
    }
    return obj
  }
  
  if (typeof obj === 'number' || typeof obj === 'boolean') {
    return String(obj)
  }
  
  if (Array.isArray(obj)) {
    if (obj.length === 0) return '[]'
    return obj.map(item => {
      const itemStr = convertToYaml(item, indent + 1)
      if (typeof item === 'object' && item !== null) {
        return `\n${spaces}- ${itemStr.trim()}`
      }
      return `\n${spaces}- ${itemStr}`
    }).join('')
  }
  
  if (typeof obj === 'object') {
    const entries = Object.entries(obj as Record<string, unknown>)
    if (entries.length === 0) return '{}'
    
    // Handle CloudFormation intrinsic functions
    if ('Ref' in obj) {
      return `!Ref ${(obj as { Ref: string }).Ref}`
    }
    if ('Fn::Sub' in obj) {
      return `!Sub "${(obj as { 'Fn::Sub': string })['Fn::Sub']}"`
    }
    if ('Fn::GetAtt' in obj) {
      const arr = (obj as { 'Fn::GetAtt': string[] })['Fn::GetAtt']
      return `!GetAtt ${arr.join('.')}`
    }
    
    return entries.map(([key, value]) => {
      const valueStr = convertToYaml(value, indent + 1)
      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
        return `${key}:\n${spaces}  ${valueStr.trim()}`
      }
      if (Array.isArray(value)) {
        return `${key}:${valueStr}`
      }
      return `${key}: ${valueStr}`
    }).join(`\n${spaces}`)
  }
  
  return String(obj)
}
